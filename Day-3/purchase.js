// ============================================
// PURCHASE ORDER & INVOICE SYSTEM
// ============================================

// Storage for Purchase Orders (Database simulation)
const purchaseOrderDatabase = {};

// Generate unique PO number: 3 capital letters + 3 numbers
function generatePONumber() {
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let po = '';
    for (let i = 0; i < 3; i++) {
        po += letters.charAt(Math.floor(Math.random() * letters.length));
    }
    for (let i = 0; i < 3; i++) {
        po += Math.floor(Math.random() * 10);
    }
    return po;
}

// Note: PO number format is generated by generatePONumber (3 letters + 3 digits)

// Calculate total amount based on salary type
function calculateTotalAmount(salary, salaryType, duration) {
    let total = 0;
    if (salaryType === 'monthly') {
        // Assuming duration is in months (e.g., "5 months")
        const months = parseInt(duration);
        total = salary * months;
    } else if (salaryType === 'daily') {
        // Assuming duration gives number of days
        const days = parseInt(duration) * 30; // rough estimate: months to days
        total = salary * days;
    } else if (salaryType === 'hourly') {
        // Assuming duration in months, ~160 hours per month
        const months = parseInt(duration);
        total = salary * months * 160;
    }
    return total;
}

// Create Purchase Order
function createPurchaseOrder(courseName, clientName, trainerName, trainerEmail, trainerExp, paymentType, rate, startDateStr, endDateStr, hours) {
    const poNumber = generatePONumber();
    let startDate = startDateStr ? new Date(startDateStr) : new Date();
    if (isNaN(startDate.getTime())) {
        startDate = new Date();
    }

    let endDate;
    if (endDateStr) {
        endDate = new Date(endDateStr);
        if (isNaN(endDate.getTime())) {
            endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 30);
        }
    } else {
        endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + 30); // 30 days from start
    }

    // determine durationUnits based on paymentType
    let durationUnits = 0;
    if (paymentType === 'hourly') {
        durationUnits = Number(hours) || 0;
    } else if (paymentType === 'daily') {
        const msPerDay = 24 * 60 * 60 * 1000;
        durationUnits = Math.ceil((endDate - startDate) / msPerDay) + 1;
        if (durationUnits < 1) durationUnits = 1;
    } else if (paymentType === 'monthly') {
        durationUnits = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth()) + 1;
        if (durationUnits < 1) durationUnits = 1;
    }

    const totalAmount = Number(rate) * durationUnits;

    const purchaseOrder = {
        poNumber: poNumber,
        courseName: courseName,
        clientName: clientName,
        trainer: {
            name: trainerName,
            email: trainerEmail,
            experience: trainerExp
        },
        paymentType: paymentType,
        rate: Number(rate),
        durationUnits: durationUnits,
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        totalAmount: totalAmount,
        status: 'active'
    };

    // Store PO in database with poNumber as key
    purchaseOrderDatabase[poNumber] = purchaseOrder;

    return purchaseOrder;
}

// Retrieve Purchase Order by PO ID
function getPurchaseOrderByID(poID) {
    if (purchaseOrderDatabase[poID]) {
        return purchaseOrderDatabase[poID];
    } else {
        return {
            status: 'error',
            message: `Purchase Order with ID "${poID}" not found.`
        };
    }
}

// Generate Invoice by PO ID
function generateInvoiceByPOID(poID) {
    const purchaseOrder = getPurchaseOrderByID(poID);

    // Check if PO exists
    if (purchaseOrder.status === 'error') {
        return purchaseOrder;
    }

    // If an invoice already exists for this PO, return it instead of creating a new one
    if (purchaseOrder.invoice) {
        return purchaseOrder;
    }

    // Check if training has completed (current date >= endDate)
    const today = new Date();
    const endDate = new Date(purchaseOrder.endDate);
    if (today < endDate) {
        throw new Error(`Training not yet completed. End date is ${purchaseOrder.endDate}.`);
    }

    // Generate invoice and attach it to the PO so invoice is part of PO data
    const invoiceId = generatePONumber();
    const invoiceDate = today.toISOString().split('T')[0];
    const due = new Date(today);
    due.setDate(due.getDate() + 30);
    const dueDateStr = due.toISOString().split('T')[0];

    const invoice = {
        invoiceId: invoiceId,
        invoiceDate: invoiceDate,
        dueDate: dueDateStr,
        poNumber: purchaseOrder.poNumber,
        trainerName: purchaseOrder.trainer.name,
        courseName: purchaseOrder.courseName,
        totalAmount: purchaseOrder.totalAmount,
        status: 'UNPAID'
    };

    purchaseOrder.invoice = invoice;
    purchaseOrder.status = 'invoiced';

    // persist change in "database"
    purchaseOrderDatabase[poID] = purchaseOrder;

    // return the purchase order with attached invoice
    return purchaseOrder;
}

// Check if 30 days have passed since PO creation
function canGenerateInvoice(poStartDate) {
    // Deprecated for invoice timing; kept for backward compatibility
    const startDate = new Date(poStartDate);
    const today = new Date();
    const daysElapsed = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
    return daysElapsed >= 30;
}

// Check all invoices for overdue status and simulate email notification
function checkOverdueInvoices() {
    const today = new Date();
    for (const poKey in purchaseOrderDatabase) {
        const po = purchaseOrderDatabase[poKey];
        if (po.invoice && po.invoice.status === 'UNPAID') {
            const due = new Date(po.invoice.dueDate);
            if (today > due) {
                po.invoice.status = 'OVERDUE';
                // Simulated email
                console.log(`Simulated email to accounts: Invoice ${po.invoice.invoiceId} for PO ${po.poNumber} is OVERDUE.`);
            }
        }
    }
}

// (Example/test code removed â€” use the interactive menu below)

// Interactive console menu
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

function ask(question) {
    return new Promise(resolve => rl.question(question, answer => resolve(answer && answer.trim())));
}

function printMenuHeader() {
    console.log('\nInteractive Purchase Order & Invoice Console\n');
        console.log('Type "po" to create a Purchase Order, \n"invoice" to generate an invoice, \n"pay" to mark an invoice paid, \n"test" to simulate overdue, \n"test-due" to simulate a due-soon invoice, or \n"exit" to quit.');
}

async function mainMenu() {
    printMenuHeader();

    while (true) {
        // check overdue invoices each loop
        checkOverdueInvoices();
        const choice = (await ask('> ')) || '';
        const cmd = choice.toLowerCase();

        if (cmd === 'exit') {
            console.log('Exiting.');
            rl.close();
            break;
        }

        if (cmd === 'po') {
            const courseName = await ask('Course name: ');
            const clientName = await ask('Client name: ');
            const trainerName = await ask('Trainer name: ');
            const trainerEmail = await ask('Trainer email: ');
            const trainerExp = await ask('Trainer experience: ');
            const paymentType = (await ask('Payment type (hourly/daily/monthly): ')).toLowerCase();
            const rateRaw = await ask('Rate per unit: ');
            const rate = parseFloat(rateRaw);
            const startDateInput = await ask('Start date (YYYY-MM-DD) [leave blank for today]: ');
            const endDateInput = await ask('End date (YYYY-MM-DD) [leave blank for start+30]: ');
            let hoursInput = null;
            if (paymentType === 'hourly') {
                hoursInput = await ask('Total hours for training: ');
            }

            const po = createPurchaseOrder(courseName, clientName, trainerName, trainerEmail, trainerExp, paymentType, rate, startDateInput, endDateInput, hoursInput);
            console.log('\nPurchase Order Created:');
            console.log(po);
            printMenuHeader();
        } else if (cmd === 'invoice') {
            const poid = await ask('Enter PO ID: ');
            try {
                const result = generateInvoiceByPOID(poid);
                console.log('\nInvoice generated and attached to PO:');
                console.log(result);
                printMenuHeader();
            } catch (err) {
                console.log('Error:', err.message);
                printMenuHeader();
            }
        } else if (cmd === 'pay') {
            const invoiceId = await ask('Enter Invoice ID to mark as PAID: ');
            let found = false;
            for (const key in purchaseOrderDatabase) {
                const po = purchaseOrderDatabase[key];
                if (po.invoice && po.invoice.invoiceId === invoiceId) {
                    po.invoice.status = 'PAID';
                    po.invoice.paymentDate = new Date().toISOString().split('T')[0];
                    console.log(`Invoice ${invoiceId} marked as PAID.`);
                    found = true;
                    break;
                }
            }
            if (!found) console.log('Invoice not found.');
            printMenuHeader();
        } else if (cmd === 'test-due') {
            runDueTest();
            printMenuHeader();
        } else if (cmd === 'test') {
            // run overdue simulation test
            runOverdueTest();
            printMenuHeader();
        } else {
            console.log('Unknown option. Enter "po", "invoice", or "exit".');
            printMenuHeader();
        }
    }
}

// Start interactive menu
mainMenu();

// ----------------
// Test utilities
// ----------------
function runOverdueTest() {
    console.log('\nRunning overdue invoice simulation test...');
    // Create PO with end date well in the past
    const start = new Date(Date.now() - 60 * 24 * 60 * 60 * 1000);
    const end = new Date(Date.now() - 50 * 24 * 60 * 60 * 1000);
    const po = createPurchaseOrder('Test Course', 'Test Client', 'Test Trainer', 'test@example.com', '5 years', 'daily', 1000, start.toISOString().split('T')[0], end.toISOString().split('T')[0]);
    console.log('Created PO:', po.poNumber);

    // Generate invoice (allowed because end date is in past)
    const generated = generateInvoiceByPOID(po.poNumber);
    console.log('Generated invoice (initial):', generated.invoice);

    // Adjust invoice date to 40 days ago so due date passed
    const invoiceDate = new Date(Date.now() - 40 * 24 * 60 * 60 * 1000);
    const due = new Date(invoiceDate);
    due.setDate(due.getDate() + 30);
    const inv = purchaseOrderDatabase[po.poNumber].invoice;
    inv.invoiceDate = invoiceDate.toISOString().split('T')[0];
    inv.dueDate = due.toISOString().split('T')[0];
    inv.status = 'UNPAID';
    console.log('Adjusted invoice to older date:', inv);

    // Run overdue check
    checkOverdueInvoices();
    console.log('After overdue check:', purchaseOrderDatabase[po.poNumber].invoice);
}

function runDueTest() {
    console.log('\nRunning due-soon invoice simulation test...');
    // Create PO with end date in the past so invoice can be generated
    const start = new Date(Date.now() - 20 * 24 * 60 * 60 * 1000);
    const end = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000);
    const po = createPurchaseOrder('DueTest Course', 'DueTest Client', 'Due Tester', 'due@example.com', '3 years', 'daily', 500, start.toISOString().split('T')[0], end.toISOString().split('T')[0]);
    console.log('Created PO:', po.poNumber);

    // Generate invoice (allowed because end date is in past)
    const generated = generateInvoiceByPOID(po.poNumber);
    console.log('Generated invoice (initial):', generated.invoice);

    // Adjust invoice date to 10 days ago so due date is in 20 days (not overdue)
    const invoiceDate = new Date(Date.now() - 10 * 24 * 60 * 60 * 1000);
    const due = new Date(invoiceDate);
    due.setDate(due.getDate() + 30);
    const inv = purchaseOrderDatabase[po.poNumber].invoice;
    inv.invoiceDate = invoiceDate.toISOString().split('T')[0];
    inv.dueDate = due.toISOString().split('T')[0];
    inv.status = 'UNPAID';
    console.log('Adjusted invoice to recent date:', inv);

    // Run overdue check (should NOT mark as overdue)
    checkOverdueInvoices();
    console.log('After overdue check (should remain UNPAID):', purchaseOrderDatabase[po.poNumber].invoice);
}